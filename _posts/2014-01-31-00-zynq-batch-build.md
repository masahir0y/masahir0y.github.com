---
layout: post
title: Zynq のビルドプロセスをスクリプト化する
description: ""
tags: [Zynq]
---
{% include JB/setup %}

Zynq の話なんですが、そこそこ慣れてくると、Vivado や XSDK の GUI が使いにくく思えてきます。

GUI というのは、最初は何となくわかりやすいような印象を与えるが、ある程度使いこなせるようになると、
CUI の方がありがたいです。

基本的に、開発中というのは「ソースコードの修正」→「ビルド」→「動作確認」の繰り返しです。

いちいち、GUI を開いて、FPGA をコンパイルしたり、ハードウェアをエクスポートして、
XSDK に食わせたりとかのルーチンワークを手動でやりたくないのです。

幸い、Vivado には Tcl インターフェースがあるので、GUI でできることは、CUI でもできるのです。

私がこれをやりたい理由を挙げると、

  - GUI は重い

  - GUI は自動実行できないので、繰り返し作業に向いていない

  - GUI は間違えやすい

  チームでの開発になったりすると、中には詳しくないメンバーもいたりする。
  特に Zynq はビルド手順がかなり複雑になってしまっているので、
  GUI でのビルド手順を習得するには、それなりに時間がかかるし、操作ミスも発生する。
  ビルドプロセスを完全にスクリプト化してしまえば、「とりあえず "make" って打っとけや」で済む。

  - GUI のプロジェクトはバージョンコントロール(git) での管理が難しい

  バージョン管理をせずに仕事を進めるというのは、恐ろしいことである。
  これをしないと、ソースを過去に戻したり、開発プロセスを他のメンバーと共有できない。
  しかしながら、Vivado のプロジェクトとバージョン管理は相性が悪い、
  というかそもそもバージョン管理のことを考えてないんじゃないかと思う。

  FPGA の時はプロジェクトが管理するのは RTL と制約ファイルぐらいだったから、
  RTL と 制約ファイルをバージョン管理して、プロジェクトはその都度、再構築すればよかった。
  しかし、Zynq の場合は、ARM 周りの設定とか、IP 間の接続とか、いろんなものがプロジェクトで管理されている。
  プロジェクト自体を git に登録するのは、一体何がソースで、
  何がジェネレートされたファイルなのかよくわからないので無理がある。

そこで、RTL や 制約ファイルとともに Vivado を制御するスクリプトを Tcl で書き、これらを git で管理することにした。

なに、大した知識は必要ない。

Tcl の初歩的な文法がわかればよい。(知らなくても 半日もあれば勉強できる。)

あとは、Vivado をコントロールするコマンド群だが、これも簡単にわかる。

Vivado を起動した時に、カレントディレクトリに `.jou` という拡張子のファイル
(Journal File) が作られるが、このファイルに、 Vivado が実行した操作が Tcl のコマンドとして記録されていく。
なので、知りたいコマンドがあるときは、GUI から一度実行してみて、Journal File
を見れば、対応するコマンドが一目瞭然なのだ。

例えば、プロジェクトを作成するのは `create_prj` だし、RTL を追加するには
`import_files`、合成は `launch_runs systh_1` でよいというのがわかる。

詳しいコマンドの意味を調べたいときは "Vivado Design Suite Tcl Command Reference Guide"
というドキュメントがある。

そんな感じで、プロジェクト作って、RTL と 制約ファイル追加して、合成して、配置配線して、
Bit ファイル作って、HW 情報をエクスポートして、なんてのをスクリプトで組んでいけばよい。

あとは Block Design だが、これも Tcl スクリプト化できる。

Block Design を開いた状態で、 Vivado のメニューから 「File → Export → Export Block Design...」
を選べば、Tcl スクリプトに出力できる。
Block Design を Tcl からプロジェクトへリストアするには、その Tclスクリプトを
`source` で読み込んで `save_bd_design` でよい。

このようにして組んだ Tcl スクリプトをバッチモードで実行するには以下のようにする。

    $ vivado -mode batch -source <tcl_file>

これで、Vivado の GUI を開く必要がなくなった。
GUI を使うのは Block Design を編集するときぐらいである。

さらには Makefile も作って、FSBL, U-Boot, Linux など他のコンポーネントも自動でビルドするようにして、
XMD からブートさせるところまで、自動化してしまいます。

このようにして作った、非常に軽量な完全自動化プロジェクトを git で履歴管理します。快適です。

PetaLinux も Xilinx が用意してくれているオールインの環境（あまり詳しくない）だと思うが、こちらはかなり重そう。。
